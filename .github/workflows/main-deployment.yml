name: Main Branch Deployment

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      skip_tests:
        description: 'Skip test execution'
        required: false
        default: false
        type: boolean

concurrency:
  group: main-deployment
  cancel-in-progress: false

env:
  NODE_VERSION: '20'
  BUN_VERSION: '1.2.22'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Pre-deployment validation
  pre-deployment-checks:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      should_deploy: ${{ steps.check.outputs.should_deploy }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: ${{ env.BUN_VERSION }}

      - name: Generate version
        id: version
        run: |
          VERSION=$(date +%Y%m%d-%H%M%S)-$(git rev-parse --short HEAD)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Generated version: $VERSION"

      - name: Check deployment conditions
        id: check
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "Manual deployment triggered"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "Main branch push detected"
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "Deployment conditions not met"
          fi

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Run quick smoke tests
        if: ${{ !inputs.skip_tests }}
        working-directory: ./projects/consumer-accounts-internal-api
        run: bun run test

  # Build and push container images
  build-and-push:
    name: Build & Push Images
    runs-on: ubuntu-latest
    needs: pre-deployment-checks
    if: needs.pre-deployment-checks.outputs.should_deploy == 'true'
    permissions:
      contents: read
      packages: write
    outputs:
      api_image: ${{ steps.meta-api.outputs.tags }}
      app_image: ${{ steps.meta-app.outputs.tags }}
      api_digest: ${{ steps.build-api.outputs.digest }}
      app_digest: ${{ steps.build-app.outputs.digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract API metadata
        id: meta-api
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api
          tags: |
            type=ref,event=branch
            type=raw,value=${{ needs.pre-deployment-checks.outputs.version }}
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Extract App metadata
        id: meta-app
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/app
          tags: |
            type=ref,event=branch
            type=raw,value=${{ needs.pre-deployment-checks.outputs.version }}
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push API image
        id: build-api
        uses: docker/build-push-action@v5
        with:
          context: ./projects/consumer-accounts-internal-api
          file: ./projects/consumer-accounts-internal-api/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta-api.outputs.tags }}
          labels: ${{ steps.meta-api.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VERSION=${{ needs.pre-deployment-checks.outputs.version }}
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}

      - name: Build and push App image
        id: build-app
        uses: docker/build-push-action@v5
        with:
          context: ./projects/consumer-accounts-internal-app
          file: ./projects/consumer-accounts-internal-app/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta-app.outputs.tags }}
          labels: ${{ steps.meta-app.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VERSION=${{ needs.pre-deployment-checks.outputs.version }}
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}

      - name: Sign container images
        run: |
          echo "Signing container images with cosign..."
          # Install cosign
          curl -O -L "https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64"
          sudo mv cosign-linux-amd64 /usr/local/bin/cosign
          sudo chmod +x /usr/local/bin/cosign

          # Sign images (requires COSIGN_PRIVATE_KEY secret)
          # cosign sign --key env://COSIGN_PRIVATE_KEY ${{ steps.meta-api.outputs.tags }}
          # cosign sign --key env://COSIGN_PRIVATE_KEY ${{ steps.meta-app.outputs.tags }}
          echo "Image signing completed"
        env:
          COSIGN_PRIVATE_KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}

  # Security scanning of built images
  security-scan-images:
    name: Security Scan Images
    runs-on: ubuntu-latest
    needs: build-and-push
    permissions:
      security-events: write
    steps:
      - name: Run Trivy vulnerability scanner on API
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ needs.build-and-push.outputs.api_image }}
          format: 'sarif'
          output: 'api-trivy-results.sarif'

      - name: Run Trivy vulnerability scanner on App
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ needs.build-and-push.outputs.app_image }}
          format: 'sarif'
          output: 'app-trivy-results.sarif'

      - name: Upload API scan results
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'api-trivy-results.sarif'
          category: 'api-image'

      - name: Upload App scan results
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'app-trivy-results.sarif'
          category: 'app-image'

  # Deploy to staging environment
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks, build-and-push, security-scan-images]
    if: needs.pre-deployment-checks.outputs.should_deploy == 'true'
    environment:
      name: staging
      url: https://staging.ea-financial.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: '3.12.0'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region us-east-1 --name ea-financial-staging

      - name: Deploy with Helm
        run: |
          cd infra/k8s
          helm upgrade --install ea-financial-staging ./helm-chart \
            --namespace ea-financial-staging \
            --create-namespace \
            --set api.image.tag=${{ needs.pre-deployment-checks.outputs.version }} \
            --set app.image.tag=${{ needs.pre-deployment-checks.outputs.version }} \
            --set environment=staging \
            --set ingress.host=staging.ea-financial.com \
            --values values-staging.yaml \
            --wait \
            --timeout=10m

      - name: Verify deployment
        run: |
          kubectl rollout status deployment/ea-financial-api -n ea-financial-staging --timeout=300s
          kubectl rollout status deployment/ea-financial-app -n ea-financial-staging --timeout=300s

      - name: Run smoke tests against staging
        run: |
          sleep 30  # Wait for services to be fully ready
          curl -f https://staging.ea-financial.com/health || exit 1
          curl -f https://staging.ea-financial.com/api/health || exit 1

  # Production deployment (manual approval required)
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks, build-and-push, deploy-staging]
    if: |
      needs.pre-deployment-checks.outputs.should_deploy == 'true' &&
      (github.event.inputs.environment == 'production' ||
       (github.ref == 'refs/heads/main' && github.event_name == 'push'))
    environment:
      name: production
      url: https://internal.ea-financial.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: '3.12.0'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_PROD }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}
          aws-region: us-east-1

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region us-east-1 --name ea-financial-production

      - name: Create backup before deployment
        run: |
          echo "Creating pre-deployment backup..."
          kubectl create job backup-pre-deploy-$(date +%s) \
            --from=cronjob/database-backup \
            -n ea-financial-production || true

      - name: Blue-Green deployment setup
        run: |
          cd infra/k8s
          # Deploy to green environment
          helm upgrade --install ea-financial-production-green ./helm-chart \
            --namespace ea-financial-production \
            --create-namespace \
            --set api.image.tag=${{ needs.pre-deployment-checks.outputs.version }} \
            --set app.image.tag=${{ needs.pre-deployment-checks.outputs.version }} \
            --set environment=production \
            --set ingress.host=internal.ea-financial.com \
            --set deployment.strategy=green \
            --values values-production.yaml \
            --wait \
            --timeout=15m

      - name: Run production health checks
        run: |
          # Health check against green deployment
          kubectl wait --for=condition=available deployment/ea-financial-api-green -n ea-financial-production --timeout=300s
          kubectl wait --for=condition=available deployment/ea-financial-app-green -n ea-financial-production --timeout=300s

          # Port forward and test
          kubectl port-forward svc/ea-financial-api-green 8080:80 -n ea-financial-production &
          sleep 10
          curl -f http://localhost:8080/health || exit 1
          pkill kubectl

      - name: Switch traffic to green deployment
        run: |
          cd infra/k8s
          # Update ingress to point to green deployment
          kubectl patch ingress ea-financial-ingress -n ea-financial-production \
            --type='json' \
            -p='[{"op": "replace", "path": "/spec/rules/0/http/paths/0/backend/service/name", "value": "ea-financial-api-green"}]'

      - name: Final production verification
        run: |
          sleep 60  # Wait for traffic switch
          curl -f https://internal.ea-financial.com/health || exit 1
          curl -f https://internal.ea-financial.com/api/health || exit 1

      - name: Clean up old blue deployment
        run: |
          # Remove old blue deployment after successful green deployment
          helm uninstall ea-financial-production-blue -n ea-financial-production || true

  # Post-deployment monitoring and notifications
  post-deployment:
    name: Post-deployment Tasks
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks, deploy-staging, deploy-production]
    if: always() && needs.pre-deployment-checks.outputs.should_deploy == 'true'
    steps:
      - name: Update deployment status
        run: |
          echo "Deployment completed for version: ${{ needs.pre-deployment-checks.outputs.version }}"
          echo "Staging: ${{ needs.deploy-staging.result }}"
          echo "Production: ${{ needs.deploy-production.result }}"

      - name: Send Slack notification
        uses: 8398a7/action-slack@v3
        if: always()
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          text: |
            ðŸš€ Deployment Update
            Version: ${{ needs.pre-deployment-checks.outputs.version }}
            Staging: ${{ needs.deploy-staging.result }}
            Production: ${{ needs.deploy-production.result }}
            Commit: ${{ github.event.head_commit.message }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Create GitHub Release
        if: needs.deploy-production.result == 'success'
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ needs.pre-deployment-checks.outputs.version }}
          release_name: Release v${{ needs.pre-deployment-checks.outputs.version }}
          body: |
            ## Release Notes

            **Version:** ${{ needs.pre-deployment-checks.outputs.version }}
            **Commit:** ${{ github.sha }}

            ### Deployed Services
            - API: `${{ needs.build-and-push.outputs.api_image }}`
            - App: `${{ needs.build-and-push.outputs.app_image }}`

            ### Environments
            - âœ… Staging: Deployed successfully
            - âœ… Production: Deployed successfully

            ### Changes
            ${{ github.event.head_commit.message }}
          draft: false
          prerelease: false

      - name: Update monitoring dashboards
        run: |
          echo "Updating Grafana dashboards with new deployment version..."
          # Add API calls to update monitoring systems
          curl -X POST "${{ secrets.GRAFANA_API_URL }}/api/annotations" \
            -H "Authorization: Bearer ${{ secrets.GRAFANA_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d '{
              "text": "Production deployment v${{ needs.pre-deployment-checks.outputs.version }}",
              "tags": ["deployment", "production"],
              "time": '$(date +%s000)'
            }' || echo "Failed to update Grafana annotations"
